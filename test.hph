
@config
{
  @output_file_name `test`
  @output_path `../src/`
}


@table
Vector_Types_Table (type)
{
  { `u8 ` } { u16 } { u32 } { u64 }
  { `s8 ` } { s16 } { s32 } { s64 }
                    { f32 } { f64 }
}

@generate @h_file
{
  `#ifndef MATH_HEPHAESTUS_H\n#define UI_HEPHAESTUS_H\n\n`
  `/*\n@Hephaestus generated code\n*/\n\n`
}

// Vector 2
// --------
@generate @h_file
{
  `// Vector2\n`
  `// -------`
  @foreach(Vector_Types_Table) `typedef union Vec2$(type) { $(type) data[2]; struct { $(type) x, y; }; } Vec2$(type);
function Vec2$(type) vector2_add(Vec2$(type) a, Vec2$(type) b);
function Vec2$(type) vector2_subtract(Vec2$(type) a, Vec2$(type) b);
function Vec2$(type) vector2_multiply(Vec2$(type) a, Vec2$(type) b);
function Vec2$(type) vector2_divide(Vec2$(type) a, Vec2$(type) b);
function Vec2$(type) vector2_scale(Vec2$(type) vector, f32 scalar);
function Vec2$(type) vector2_negate(Vec2$(type) vector);
function Vec2$(type) vector2_rotate(Vec2$(type) vector, f32 radians);
function Vec2$(type) vector2_normalize(Vec2$(type) vector);
function Vec2$(type) vector2_linear_interpolate(Vec2$(type) a, Vec2$(type) b, f32 t);
function Vec2$(type) vector2_minimum(Vec2$(type) a, Vec2$(type) b);
function Vec2$(type) vector2_maximum(Vec2$(type) a, Vec2$(type) b);
function Vec2$(type) vector2_clamp(Vec2$(type) vector, Vec2$(type) minimum, Vec2$(type) maximum);
function Vec2$(type) vector2_absolute(Vec2$(type) vector);
function Vec2$(type) vector2_perpendicular(Vec2$(type) vector);
function Vec2$(type) vector2_reflect(Vec2$(type) incident, Vec2$(type) normal);
function Vec2$(type) vector2_project(Vec2$(type) vector, Vec2$(type) onto);
function Vec2$(type) vector2_snap_to_grid(Vec2$(type) vector, f32 grid_size);
function f32 vector2_dot_product(Vec2$(type) a, Vec2$(type) b);
function f32 vector2_cross_product(Vec2$(type) a, Vec2$(type) b);
function f32 vector2_length(Vec2$(type) vector);
function f32 vector2_length_squared(Vec2$(type) vector);
function f32 vector2_distance(Vec2$(type) a, Vec2$(type) b);
function f32 vector2_distance_squared(Vec2$(type) a, Vec2$(type) b);
function f32 vector2_angle_between(Vec2$(type) a, Vec2$(type) b);
function f32 vector2_signed_angle_between(Vec2$(type) a, Vec2$(type) b);
\n`
}

// Vector 3
// --------
@generate @h_file
{
  `// Vector3\n`
  `// -------`
  @foreach(Vector_Types_Table) `typedef union Vec3$(type) { $(type) data[3]; struct { $(type) x, y, z; }; } Vec3$(type);
function Vec3$(type) vector3_add(Vec3$(type) a, Vec3$(type) b);
function Vec3$(type) vector3_subtract(Vec3$(type) a, Vec3$(type) b);
function Vec3$(type) vector3_multiply(Vec3$(type) a, Vec3$(type) b);
function Vec3$(type) vector3_divide(Vec3$(type) a, Vec3$(type) b);
function Vec3$(type) vector3_scale(Vec3$(type) vector, f32 scalar);
function Vec3$(type) vector3_negate(Vec3$(type) vector);
function Vec3$(type) vector3_normalize(Vec3$(type) vector);
function Vec3$(type) vector3_linear_interpolate(Vec3$(type) a, Vec3$(type) b, f32 t);
function Vec3$(type) vector3_minimum(Vec3$(type) a, Vec3$(type) b);
function Vec3$(type) vector3_maximum(Vec3$(type) a, Vec3$(type) b);
function Vec3$(type) vector3_clamp(Vec3$(type) vector, Vec3$(type) minimum, Vec3$(type) maximum);
function Vec3$(type) vector3_absolute(Vec3$(type) vector);
function Vec3$(type) vector3_reflect(Vec3$(type) incident, Vec3$(type) normal);
function Vec3$(type) vector3_project(Vec3$(type) vector, Vec3$(type) onto);
function Vec3$(type) vector3_snap_to_grid(Vec3$(type) vector, f32 grid_size);
function Vec3$(type) vector3_cross_product(Vec3$(type) a, Vec3$(type) b);

// Extra 3D-specific
function Vec3$(type) vector3_rotate_axis_angle(Vec3$(type) vector, Vec3$(type) axis, f32 radians);
function Vec3$(type) vector3_from_to_rotation(Vec3$(type) from, Vec3$(type) to);
function Vec3$(type) vector3_normal_from_triangle(Vec3$(type) a, Vec3$(type) b, Vec3$(type) c);

function f32 vector3_dot_product(Vec3$(type) a, Vec3$(type) b);
function f32 vector3_length(Vec3$(type) vector);
function f32 vector3_length_squared(Vec3$(type) vector);
function f32 vector3_distance(Vec3$(type) a, Vec3$(type) b);
function f32 vector3_distance_squared(Vec3$(type) a, Vec3$(type) b);
function f32 vector3_angle_between(Vec3$(type) a, Vec3$(type) b);
function f32 vector3_min_component(Vec3$(type) vector);
function f32 vector3_max_component(Vec3$(type) vector);

\n`
}

@generate @h_file
{
  `\n#endif `
  `// UI_HEPHAESTUS_H`
}

@generate @c_file
{
  
}

@generate @h_file
{
  `// @Hephaestus generated code $(@time_now)\n\n`
}

@table // Defines forward declaration for UI types
UI_Types_Table
  (name)
{
  { UI_Node_Color_Scheme }
  { UI_Color_Scheme      }
  { UI_Node              }
  { UI_Node_Cache        }
  { UI_Signal            }
  { UI_Context           }
}

@generate @h_file
{
  `// Forward declare UI structures\n`
  @foreach(UI_Types_Table) `typedef struct $(name) $(name);\n`
  `\n`
}

@table // Defines forward declare for UI enums
UI_Enum_Table
  (name)
{
  { UI_Alignment_Kind }
  { UI_Width_Kind     }
  { UI_Height_Kind    }
}

@generate @h_file
{
  `// Forward declare UI enums\n`
  @foreach(UI_Enum_Table) `typedef enum $(name) $(name)\n`
  `\n`
}

@table // Bitflags
UI_Node_Flags_Table
  (name                       documentation)
{
  { Mouse_Clickable          `TODO(fz): Add documentation` } 
  { Display_Text             `TODO(fz): Add documentation` } 
  { Draggable                `TODO(fz): Add documentation` } 
  { Hoverable                `TODO(fz): Add documentation` } 
  { Center_Text_Horizontally `TODO(fz): Add documentation` } 
  { Center_Text_Vertically   `TODO(fz): Add documentation` } 
  { Dimensions_Wrap_Text     `TODO(fz): Add documentation` } 
}

@generate @h_file
{
  `typedef u64 UI_Node_Flags;\nenum\n{\n`
  @foreach(UI_Node_Flags_Table) `  UI_Node_Flags_$(name) = (1 << $(@index)), /* $(documentation) */ \n`
  `};\n`
    `\n`
}

@table // Bitflags
UI_Signal_Flags_Table
  (name            documentation)
{
  { Left_Down      `TODO(fz): Add documentation` } 
  { Middle_Down    `TODO(fz): Add documentation` } 
  { Right_Down     `TODO(fz): Add documentation` } 

  { Left_Clicked   `TODO(fz): Add documentation` } 
  { Middle_Clicked `TODO(fz): Add documentation` } 
  { Right_Clicked  `TODO(fz): Add documentation` } 

  { Mouse_Hovered  `TODO(fz): Add documentation` } 
}

@generate @h_file
{
  `typedef u64 UI_Node_Flags;\nenum\n{\n`
  @foreach(UI_Signal_Flags_Table) `  UI_Signal_Flags_$(name) = (1 << $(@index)), /* $(documentation) */\n`
  `};\n`
  `\n`
}

@table // Defines stacks for different types
Stack_Table
  (name_upper               name_lower                 type                   default_value                     max documentation)
{
  { Node                    node                       UI_Node*               NULL                              32 `Pointer to the current UI node`      }
  { Top_Left                top_left                   Vec2f32               `vec2f32(5.0f, 5.0f)`              32 `Top-left corner position`            }
  { Size_X                  size_x                     f32                    g_os_window.dimensions.x          32 `Default X size equals window width`  }
  { Size_Y                  size_y                     f32                    g_os_window.dimensions.y          32 `Default Y size equals window height` }
  { Padding_X               padding_x                  f32                    0.0f                              32 `Horizontal padding`                  }
  { Padding_Y               padding_y                  f32                    0.0f                              32 `Vertical padding`                    }
  { Spacing_Left            spacing_left               f32                    0.0f                              32 `Left spacing (not clipped)`          }
  { Spacing_Right           spacing_right              f32                    0.0f                              32 `Right spacing (not clipped)`         }
  { Spacing_Top             spacing_top                f32                    0.0f                              32 `Top spacing (not clipped)`           }
  { Spacing_Bottom          spacing_bottom             f32                    0.0f                              32 `Bottom spacing (not clipped)`        }
  { Alignment_Kind          alignment_kind             UI_Alignment_Kind      UI_Alignment_Kind_Y               32 `Default alignment along Y`           }
  { Width_Kind              width_kind                 UI_Width_Kind          UI_Width_Kind_Fill                32 `Width filling strategy`              }
  { Height_Kind             height_kind                UI_Height_Kind         UI_Height_Kind_Fill               32 `Height filling strategy`             }
  { Node_Color_Scheme       node_color_scheme          UI_Node_Color_Scheme   ui_context.color_scheme.window    32 `Node color scheme override`          }
  { Border_Color            border_color               Color                  PURPLE(1)                         32 `Default border color`                }
  { Background_Color        background_color           Color                  PURPLE(1)                         32 `Default background color`            }
  { Background_Hover_Color  background_hover_color     Color                  PURPLE(1)                         32 `Background color on hover`           }
  { Background_Active_Color background_active_color    Color                  PURPLE(1)                         32 `Background color when active`        }
  { Text_Color              text_color                 Color                  PURPLE(1)                         32 `Default text color`                  }
  { Text_Hover_Color        text_hover_color           Color                  PURPLE(1)                         32 `Text color on hover`                 }
  { Text_Active_Color       text_active_color          Color                  PURPLE(1)                         32 `Text color when active`              }
}

@generate @c_file
{
  `#define ui_stack_init(ctx, name, bot_val) Statement((ctx)->name##_stack.top_index = 0; (ctx)->name##_stack.bottom_val = (bot_val);)
#define ui_stack_push(ctx, name, val) ((ctx)->name##_stack.data[((ctx)->name##_stack.top_index < sizeof((ctx)->name##_stack.data)/sizeof((ctx)->name##_stack.data[0])) ? (ctx)->name##_stack.top_index++ : (ctx)->name##_stack.top_index] = (val))
#define ui_stack_pop(ctx, name) (((ctx)->name##_stack.top_index > 0) ? (ctx)->name##_stack.data[--(ctx)->name##_stack.top_index] : (ctx)->name##_stack.bottom_val)
#define ui_stack_top(ctx, name) (((ctx)->name##_stack.top_index > 0) ? (ctx)->name##_stack.data[(ctx)->name##_stack.top_index-1] : (ctx)->name##_stack.bottom_val)
#define ui_stack_assert_top_at(ctx, name, at) if((ctx)->name##_stack.top_index != (at)) emit_fatal(Sf((ctx)->arena, "UI: %s not at expected top value: '%u'. Actual value: '%u'", Stringify((ctx)->name##_stack), (at), (ctx)->name##_stack.top_index))
#define ui_stack_is_at_bottom(ctx, name) ((ctx)->name##_stack.top_index == 0)
#define ui_stack_defer(ctx, name, val) DeferLoop(ui_stack_push(ctx, name, val), ui_stack_pop(ctx, name))`

  `\n\n`

  // Defines the data structures
  @foreach(Stack_Table) `/* $(documentation) */
typedef struct UI_$(name_upper)_stack UI_$(name_upper)_stack;
struct UI_$(name_upper)_stack { $(type) data[$(max)]; u32 top_index; $(type) bottom_val; };
#define ui_$(name_lower)_stack_init(bot_val) ui_stack_init(&ui_context, $(name_lower), bot_val)
#define ui_$(name_lower)_stack_push(val) ui_stack_push(&ui_context, $(name_lower), val)
#define ui_$(name_lower)_stack_pop() ui_stack_pop(&ui_context, $(name_lower))
#define ui_$(name_lower)_stack_top() ui_stack_top(&ui_context, $(name_lower))
#define ui_$(name_lower)_stack_is_at_bottom() ui_stack_is_at_bottom(&ui_context, $(name_lower))
#define ui_$(name_lower)_stack_assert_top_at(at) ui_stack_assert_top_at(&ui_context, $(name_lower), at)
#define ui_set_$(name_lower)(val) DeferLoop($(name_lower)_stack_push(val), $(name_lower)_stack_pop())\n\n`

  // Defines the UI_Context member attributes
  `// Put this macro on UI_Context\n`
  `#define UI_Config_Stacks() \\n`
  @foreach(Stack_Table) `  UI_$(name_upper)_stack $(name_lower)_stack; \\n`
  `/* Macro end */`
}



